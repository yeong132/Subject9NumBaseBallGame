# 📌프로젝트 소개
- 이 프로젝트는 숫자 야구 게임입니다.<br>
- 원조 게임은 4자리 숫자로 하는 Bulls and Cows로 이 게임은 3자리 숫자로 진행됩니다.<br>
- 총 플레이어는 2명이고, 각자 목표 숫자를 맞출 기회를 3번씩 가집니다.<br>
- 멀티플레이 게임이며, 정답을 맞출 기회가 소진될 동안 목표 숫자를 더 빨리 맞추는 플레이어가 이기게 됩니다.<br>
- 게임이 끝나면 결과를 보여주고 5초 뒤에 새 게임이 시작됩니다.

<strong>하지만, 정확히 3자리가 숫자가 아닌 틀린 입력을 하게 되면 바로 상대 플레이어가 이기게 되니 주의하십시오.</strong>

---
# 📌기능
## 💎 기본 기능
### GameMode 서버 로직
채팅 기반으로 명령어를 입력하면 서버가 이를 해석해서 게임 로직을 처리합니다.<br>
게임 판정이나 흐름은 서버쪽인 게임모드가 주로 관리하도록 하였습니다.

---
### 3자리 난수 생성 로직 (중복 없는 1~9 숫자)
게임 시작시 서버에서 무작위 3자리 숫자를 만듭니다. 각 숫자마다 중복은 불가능합니다.<br>
예를 들어, 123, 456, 789는 가능하지만 111, 112, 999 같은 숫자는 만들어지지 않습니다.

---
### 판정 로직 (S/B/OUT 계산)
서버가 생성한 숫자와 플레이어가 입력한 숫자를 비교해서 스트라이크(S), 볼(B), 아웃(OUT)을 계산합니다.<br>
예를 들어, 서버 숫자가 123이고 플레이어 숫자가 132면 두 숫자의 자리수를 하나씩 비교해가는 것이다.<br>

첫번째 자리수가 같으니 판정 메시지는 "1S"<br>
두번째 자리수는 다르지만 값이 존재하니까 판정 메시지는 "1S 1B"<br>
세번째 자리수도 다르지만 값이 존재하니까 판정 메시지는 "1S 2B"

---
### 시도 횟수 및 상태 관리
중복 숫자가 포함된 입력, 3자리가 아닌 입력은 아웃(OUT) 처리됩니다.<br>
입력할 때마다 플레이어별 남은 시도 횟수를 갱신합니다.

---
### 승리, 무승부, 게임 리셋
#### 승리 조건
목표 숫자를 더 빨리 맞추는 플레이어가 승리하게 됩니다.<br>
상대 플레이어가 잘못된 입력을 하면 즉시 승리하게 됩니다.
#### 무승부 조건
둘 다 목표 숫자를 맞추지 못하고 기회를 모두 소진하면 무승부하게 됩니다.
#### 게임 리셋 조건
승리하거나 무승부하면 게임이 리셋되어야 합니다.<br>
결과는 보고 재시작해야하니 게임이 끝난 후 5초 뒤에 재시작됩니다.

---
## 💎 추가기능
### 게임 거의 동시에 시작
게임의 공정성을 위해 모든 플레이어(2명)가 접속하면 게임이 거의 동시에 시작됩니다.<br>
게임이 시작하면 각 플레이어의 UI와 시작 메시지도 거의 동시에 화면에 띄워집니다.
### 맞출 기회가 0이거나 잘못된 입력을 한 플레이어의 UI 비활성화
만약 플레이어가 맞출 기회가 0인데 입력을 더 할 수 있으면 오류가 발생할 확률이 높으니 해당 기능을 추가했습니다.

---
## 💎 고려사항
좀 더 신경써서 만든 부분입니다.
### C++ 라이브러리 분리
판정(S/B 계산)과 난수 생성 로직은 게임 흐름에 영향없이 그저 계산만 해주는 로직이기 때문에<br>
코드 가독성을 위해 서버에서 처리되는 순수 계산만 하는 로직을 C++ 라이브러리로 분리했습니다.<br>
GameMode에서 판정과 난수 생성을 하더라도 그 계산 로직은 다른 라이브러리의 함수에서 결과를 받아와 사용했습니다.

### 클린코드 만들기
아직은 뭐가 제대로 된 클린코드인지 모르는 단계지만 최대한 배운것들을 써서 코드를 리팩토링했습니다.
1. 변수나 함수명 주석 안써도 쉽게 뭐하는 역할인지 알 수 있게 이름 잘 짓기
2. 그러면 주석이 필요없어지니까 쓸데 없는 주석 삭제하기
3. 중복되거나 복잡한 코드 부분을 그 코드 집합의 목적/역할에 맞춰 작은 메서드 단위로 분리하기

---
# 📌구현 과정
## 1. 프로젝트 초기 세팅
채팅 기능이 구현되어 있는 샘플 프로젝트를 다운받아 사용했습니다.<br>
거기서 기존 채팅 기능은 완벽히 구현되어 있지 않았지만 거기서 기반을 잡고<br>
필요한 클래스들을 하나씩 추가하며 숫자야구 게임처럼 만들었습니다.

---
## 2. 사용한 클래스
### YMGameMode.cpp
- 게임의 전반적인 흐름을 담당합니다.
- 서버 RPC가 있습니다.

---
### YMGameModeLibrary.cpp
- 게임모드 클래스에서는 오직 게임의 흐름만 담당하도록 그 흐름을 위해<br>
값을 계산하는 로직 부분은 게임모드 라이브러리에 함수로 구현했습니다.

---
### YMGameState.cpp
- 두 플레이어가 동시에 받아야 할 시작 메시지나 입력 메시지를 보낼 용도로 멀티캐스트 함수를 넣었습니다.
  - 왜? 게임 스테이트는 인스턴스가 서버와 클라이언트에 존재하기에 서버에서 1번만 멀티캐스트를 해주면<br>
  멀티캐스트 함수를 호출한 객체를 가지고 있는 모든 클라이언트에서 그 함수를 실행하기 때문입니다.
- 현재 게임에 접속 중인 플레이어 수가 저장됩니다.(2명)
  - 이것을 기준으로 모든 플레이어가 접속하면 그 타이밍에 게임을 동시에 시작되게 하기 위해서 입니다.

---
### YMPlayerController.cpp
- 각 플레이어마다 UI에 들어가는 자신의 닉네임은 다르게 나와야 합니다.
- 어느 플레이어의 숫자를 맞출 기회가 다 사라지면 그 플레이어의 UI만 비활성화되어야 합니다.
- 그래서, 각각 다르게 나올 UI와 관련된 함수를 넣었습니다.
- 플레이어의 입력을 받는 서버RPC도 있습니다. 왜냐하면 또, 각 플레이어의 입력은 입력을 한 쪽에서만 받으면 되기 때문입니다.

---
### YMPlayerState.cpp
- 각 플레이어마다 가지고 있어야 되는 정보가 멤버 변수로 있습니다. (플레이어 닉네임, 목표 숫자를 맞출 기회)

---
## 만들어 놓고 아직 사용하지 않는 클래스
### YMHUD.cpp
- 완성도가 있어 보이려면 UI가 멋져야 한다고 생각했습니다.
- 그래서 미리 만들어뒀는데 과제 제출 마감기한이 되어서 주말에 수정해보겠습니다.

---
### MyBlueprintFunctionLibrary.cpp
- 이것도 쓸 일이 있을거 같았는데 블루프린트 노드가 복잡해 C++코드로 변환하는 과정에서 필요가 없어졌습니다.

> ChatWidget은 블루프린트 노드를 그대로 썼습니다. 아마 주말에 UI 작업을 하면 그게 사라지고 YMHUD를 쓸 거 같습니다.

---
## 4. 기능 구현과정
여기는 독백으로 작성했습니다.
### 4.1. 3자리 난수 생성 로직 
1. 랜덤 숫자를 뽑을 방식을 선택한다.
2. 숫자를 FString 타입으로 바꿀 것이라 Printf와 %d를 활용해서 랜덤한 숫자를 각 자리에 문자로 넣었다. (예: "%d%d%d", num1, num2, num3)
3. 각 숫자마다 중복을 어떻게 없앨지 생각한다.
4. 그렇게 구해진 3자리 난수를 반환하는 함수 작성 끝!

---
### 4.2. 판정 로직
Strike, Ball, Out값을 선언하려고 했다. 나중에 구조체로 바꿔주었다.
1. 플레이어가 입력한 문자열과 4.1. 에서 구한 3자리 난수 문자열이랑 어떻게 자리수를 비교할지 생각한다.
2. for문을 써서 각 자리수가 일치할 경우를 생각한다. `AnswerNum[i] == GuessNum[i]` 이런식으로 생각을 코드로 변환했다.
3. 그렇게 자리수가 일치하면 Strike가 올라가게 하고 자리수가 일치하지 않지만<br> 플레이어 입력 숫자가 목표 숫자에도 존재하면 Ball의 값이 올라가도록 했다.
4. Ball을 구하는 방법을 생각할 때 조건은 gpt의 도움을 받았다.
5. Out은 3에서 Strike와 Ball을 뺀 값으로 해주었다. 끝!

---
### 4.3. 시도 횟수 및 상태 관리
1. 시도 횟수를 언리얼 프레임워크 중 어디에 넣을지 몰라 다양한 곳에 멤버 변수로 넣어보다가 PlayerState가 가장 적절한 곳이란 것을 알게 됨.
2. 입력이 유효하지 않으면 시도 횟수가 0으로 감소하는 함수를 먼저 PlayerState에 선언 및 구현.
3. 정상입력을 받았을때 시도 횟수가 감소하는 함수도 PlayerState에 선언 및 구현. 끝!

---
### 4.4. 승리, 무승부, 게임 리셋
1. 어디에서 승리, 무승부, 게임 리셋을 담당하는 함수를 쓸까 고민했다.
2. 결국 플레이어 입력을 받으면 호출되는 서버RPC와 연결해서 거기서 승리, 무승부, 게임 리셋을 처리하기로 했다.
3. 세부 구현은 언제 승리할 지, 언제 무승부가 될지를 생각해 조건부터 생각했다.
4. 그러다 필요한 변수가 생기면 어디서 만들지 생각한 다음 만들고 가져왔다.
5. 게임 리셋도 언제 될 지 조건부터 생각했고 게임 리셋이 될 때 실제로 리셋될 변수들을 생각했다.
6. 변수들을 리셋할 함수를 어디서 만들지 또 고민했다. 구현 완료. 끝!

---
### 4.5. 게임 거의 동시에 시작
1. 어떻게 모든 플레이어가 접속할 때까지 Host가 Guest를 기다릴 수 있을지 방법을 생각했다.
2. 그냥 처음에 UI를 숨겨놨다가 두 플레이어가 동시에 접속한 시점에 UI를 동시에 띄워주기로 했다.
3. PostLogin이란 함수를 이용해봤지만 그래도 접속하고 나서 UI에 정보를 넣으려면 리플리케이트가 되어야 한다는 것을 깨달았다.
4. PostLogin도 쓰고 그 안에 타이머도 집어넣어서 확실히 클라이언트의 정보가 리플리케이트 된 후 UI를 동시에 띄워주기로 했다. 끝!

---
### 4.6. 맞출 기회가 0이거나 잘못된 입력을 한 플레이어의 UI 비활성화
1. 언리얼의 프레임워크 중 어디서 UI 비활성화 함수를 작성해야 되나 고민했다.
2. 입력을 잘못한 플레이어의 UI만 바뀌는거니까 각 클라이언트에 플레이어 컨트롤러가 자기것만 있어서 그곳에서 작성하기로 했다. 끝!
